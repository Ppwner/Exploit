# Toddler's Bottle

![list](./img/list.png)

## List
- fd
- collsion
- bof
- flag
- passcode
- random
- input
- leg
- mistake
- shellshock   
- coin1
- blackjack
- lotto
- cmd1
- cmd2
- uaf
- memcpy
- asm
- unlink

## fd

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
char buf[32];
int main(int argc, char* argv[], char* envp[]){
	if(argc<2){
		printf("pass argv[1] a number\n");
		return 0;
	}
	int fd = atoi( argv[1] ) - 0x1234;
	int len = 0;
	len = read(fd, buf, 32);
	if(!strcmp("LETMEWIN\n", buf)){
		printf("good job :)\n");
		system("/bin/cat flag");
		exit(0);
	}
	printf("learn about Linux file IO\n");
	return 0;

}
```
다음같은 코드가 주어진다.

| fd | action |
|:--------|:--------|
| 0  | stdin |
| 1  | stdout |
| 2  | stderr |
| 3~ | File |

fd는 다음과 같이 이루어진다. 따라서 read시 fd값을 우리가 조절할 수 있으므로, 이를 0으로 만들어 stdin으로 input을 받으면, buf에 원하는 값을 넣을 수 있을것이다.

![fd](./img/fd.png)

__Flag__ : mommy! I think I know what a file descriptor is!!

## collision

```
#include <stdio.h>
#include <string.h>
unsigned long hashcode = 0x21DD09EC;
unsigned long check_password(const char* p){
	int* ip = (int*)p;
	int i;
	int res=0;
	for(i=0; i<5; i++){
		res += ip[i];
	}
	return res;
}

int main(int argc, char* argv[]){
	if(argc<2){
		printf("usage : %s [passcode]\n", argv[0]);
		return 0;
	}
	if(strlen(argv[1]) != 20){
		printf("passcode length should be 20 bytes\n");
		return 0;
	}

	if(hashcode == check_password( argv[1] )){
		system("/bin/cat flag");
		return 0;
	}
	else
		printf("wrong passcode.\n");
	return 0;
}
```
다음같은 코드가 주어진다.
길이다 20이여야 하고, hashcode된 값이 check_password(argv[1])의 값과 같아야한다.
단순하게 0x21DD09EC를 5로 나누어서 넣어주면 되는데, 4가 남으므로 마지막꺼에는 4를 더한값을 넣어주면 된다.

![collision](./img/collision.png)

__Flag__ : daddy! I just managed to create a hash collision :)

## bof

```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
void func(int key){
	char overflowme[32];
	printf("overflow me : ");
	gets(overflowme);	// smash me!
	if(key == 0xcafebabe){
		system("/bin/sh");
	}
	else{
		printf("Nah..\n");
	}
}
int main(int argc, char* argv[]){
	func(0xdeadbeef);
	return 0;
}

```
다음같은 코드가 주어진다.
overflowme에서 input을 받을때 gets를 써서 bof가 일어난다.
이를 통해서 key를 0xcafebabe로 덮어주면 된다.

![bof1](./img/bof1.png)

offset : 0x2c + 8 = 52

![bof2](./img/bof2.png)

__Flag__ : daddy, I just pwned a buFFer :)

## flag

리버싱문제라면서 바이너리만 준다.

![flag1](./img/flag1.png)

upx로 패킹되어있다고 하니 풀어주면 될거 같다.

![flag2](./img/flag2.png)

![flag2](./img/flag3.png)

__Flag__ : UPX...? sounds like a delivery service :)

## passcode

```
#include <stdio.h>
#include <stdlib.h>

void login(){
	int passcode1;
	int passcode2;

	printf("enter passcode1 : ");
	scanf("%d", passcode1);
	fflush(stdin);

	// ha! mommy told me that 32bit is vulnerable to bruteforcing :)
	printf("enter passcode2 : ");
    scanf("%d", passcode2);

	printf("checking...\n");
	if(passcode1==338150 && passcode2==13371337){
                printf("Login OK!\n");
                system("/bin/cat flag");
        }
        else{
                printf("Login Failed!\n");
		exit(0);
        }
}

void welcome(){
	char name[100];
	printf("enter you name : ");
	scanf("%100s", name);
	printf("Welcome %s!\n", name);
}

int main(){
	printf("Toddler's Secure Login System 1.0 beta.\n");

	welcome();
	login();

	// something after login...
	printf("Now I can safely trust you that you have credential :)\n");
	return 0;	
}
```
다음과 같은 코드를 준다.
보면 scanf를 받을때 &를 안적어서, 바로 주소에다가 적을 수 있다.
<br>그리고 name을 받는 함수 실행후에, scanf부분이 실행되는데, uninitialized stack이므로, 원하는 주소에 원하는 값을 쓸 수 있게 된다. <br>고로 exit의 got를 system("/bin/cat flag")의 주소로 바꿔주면 flag를 얻을 수 있다. %d로 받으니까 10진수로 바꿔주자.

![passcode](./img/passcode.png)
__Flag__ : Sorry mom.. I got confused about scanf usage :(

